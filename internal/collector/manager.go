package collector

import (
	"sync"

	"github.com/prometheus/client_golang/prometheus"
)

type CollectorManager struct {
	collectors map[string]*MyCollector
	reg        *prometheus.Registry
	mutex      sync.Mutex
}

func NewCollectorManager(reg *prometheus.Registry) *CollectorManager {
	return &CollectorManager{
		collectors: make(map[string]*MyCollector),
		reg:        reg,
	}
}

func (m *CollectorManager) AddCollector(id string, collector *MyCollector) {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	m.collectors[id] = collector
	m.reg.Register(collector)
}

func (m *CollectorManager) RemoveCollector(id string) {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	delete(m.collectors, id)
}

func (m *CollectorManager) RemoveCollectorReg(id string) {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	collector, exists := m.collectors[id]
	if exists {
		m.reg.Unregister(collector)
		delete(m.collectors, id)
	}
}

func (m *CollectorManager) ListCollectors() []string {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	ids := make([]string, 0, len(m.collectors))
	for id := range m.collectors {
		ids = append(ids, id)
	}
	return ids
}

func (m *CollectorManager) CollectorExists(id string) bool {
	m.mutex.Lock()
	defer m.mutex.Unlock()
	_, exists := m.collectors[id]
	return exists
}

func (m *CollectorManager) Copy() *CollectorManager {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	newManager := NewCollectorManager(m.reg)
	for id, collector := range m.collectors {
		newManager.collectors[id] = collector // Shallow copy
		// If deep copy is needed, implement deep copy logic here
	}
	return newManager
}
