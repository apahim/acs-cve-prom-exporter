package acs

import (
	"context"
	"crypto/tls"
	"fmt"
	"github.com/Khan/genqlient/graphql"
	"github.com/apahim/acs-cve-prom-exporter/internal/collector"
	"github.com/apahim/acs-cve-prom-exporter/internal/gql"
	"github.com/prometheus/client_golang/prometheus"
	"log"
	"net/http"
	"strconv"
	"time"
)

type bearerTokenTransport struct {
	Base  http.RoundTripper
	Token string
}

func (t *bearerTokenTransport) RoundTrip(req *http.Request) (*http.Response, error) {
	clonedReq := req.Clone(req.Context())
	clonedReq.Header.Set("Authorization", fmt.Sprintf("Bearer %s", t.Token))
	return t.Base.RoundTrip(clonedReq)
}

type Client struct {
	reg       *prometheus.Registry
	gqlClient graphql.Client
}

func NewMetricsGenClient(reg *prometheus.Registry, endpoint string, token string) (*Client, error) {
	transport := &bearerTokenTransport{
		Base: &http.Transport{
			TLSClientConfig: &tls.Config{
				MinVersion: tls.VersionTLS13,
			},
		},
		Token: token,
	}

	httpClient := http.Client{
		Transport: transport,
		Timeout:   time.Second * 50,
	}

	gqlClient := graphql.NewClient(fmt.Sprintf("%s/api/graphql", endpoint), &httpClient)

	return &Client{
		reg:       reg,
		gqlClient: gqlClient,
	}, nil
}

func (acs *Client) GetClusters() (*gql.GetClustersResponse, error) {
	ctx := context.Background()

	resp, err := gql.GetClusters(
		ctx,
		acs.gqlClient,
	)
	if err != nil {
		log.Printf("Error fetching data: %v", err)
		return nil, err
	}
	return resp, nil
}

func (acs *Client) GetNamespaces(clusterId string) (*gql.GetNamespacesByClusterIDResponse, error) {
	ctx := context.Background()

	resp, err := gql.GetNamespacesByClusterID(
		ctx,
		acs.gqlClient,
		clusterId,
	)
	if err != nil {
		log.Printf("Error fetching data: %v", err)
		return nil, err
	}
	return resp, nil
}

func (acs *Client) GetNamespaceVulnerabilities(namespaceId string) (*gql.GetImageVulnerabilitiesByNamespaceIDResponse, error) {
	ctx := context.Background()

	resp, err := gql.GetImageVulnerabilitiesByNamespaceID(
		ctx,
		acs.gqlClient,
		namespaceId,
	)
	if err != nil {
		log.Printf("Error fetching data: %v", err)
		return nil, err
	}
	return resp, nil
}

func ProccessVulnerabilities(
	reg *prometheus.Registry,
	metricsGenClient *Client,
	cluster gql.GetClustersClustersCluster,
	namespace gql.GetNamespacesByClusterIDClusterNamespacesNamespace,
) {

	defer func() {
		if err := recover(); err != nil {
			log.Println("panic occurred:", err)
		}
	}()

	log.Printf("Getting Vulnerabilities for cluster %s namespace %s", cluster.Name, namespace.Metadata.Name)
	vulnerabilities, _ := metricsGenClient.GetNamespaceVulnerabilities(namespace.Metadata.Id)
	for _, vulnerability := range vulnerabilities.Namespace.ImageVulnerabilities {
		if vulnerability.IsFixable {
			log.Printf("Getting Images for vulnerability %s", vulnerability.Cve)
			for _, image := range vulnerability.Images {
				myCollector := collector.NewMyCollector(
					prometheus.Labels{
						"cluster":         cluster.Name,
						"cve":             vulnerability.Cve,
						"severity":        vulnerability.Severity,
						"isFixable":       strconv.FormatBool(vulnerability.IsFixable),
						"deploymentCount": strconv.FormatInt(int64(vulnerability.DeploymentCount), 10),
						"namespace":       namespace.Metadata.Name,
						"imageRemote":     image.Name.Remote,
						"imageRegistry":   image.Name.Registry,
						"imageTag":        image.Name.Tag,
						"imageId":         image.Id,
						"operatingSystem": vulnerability.OperatingSystem,
					},
					vulnerability.Cvss,
				)

				err := reg.Register(myCollector)
				if err != nil {
					log.Printf("Collector already existed, cleaning up first")
					reg.Unregister(myCollector)
					err := reg.Register(myCollector)
					if err != nil {
						panic(err)
					}
				}
			}
		}
	}
}

func ProcessNamespaces(reg *prometheus.Registry, metricsGenClient *Client) {
	defer func() {
		if err := recover(); err != nil {
			log.Println("panic occurred:", err)
		}
	}()

	log.Printf("Getting Clusters")
	clusters, _ := metricsGenClient.GetClusters()
	for _, cluster := range clusters.Clusters {

		log.Printf("Getting Namespaces for cluster %s", cluster.Name)
		namespaces, _ := metricsGenClient.GetNamespaces(cluster.Id)
		for _, namespace := range namespaces.Cluster.Namespaces {

			// Don't!!!
			// Don't even think about it!
			// Calling this in goroutines will DoS the ACS Central API.
			ProccessVulnerabilities(reg, metricsGenClient, cluster, namespace)

		}
	}
}

func Run(reg *prometheus.Registry, endpoint string, token string) {
	metricsGenClient, _ := NewMetricsGenClient(
		reg,
		endpoint,
		token,
	)
	for {
		log.Println("Beginning collection from ACS...")
		ProcessNamespaces(reg, metricsGenClient)
		log.Println("Collection completed.")
	}
}
